目录
	2pc 两阶段提交
	3pc 三阶段提交
	tcc try-confirm-cancel
	paxos

2pc：
	两阶段提交，参与角色为协调者，参与者，可以概括为串行锁资源-提交或者回滚，强一致；
	第一阶段 pre commit：
		协调者依次向协调者发出询问是否可以执行事务，参与者如果能执行的话写redo log（记录写之后的数据，用于保证
		数据库写入）和undo log（记录写之前的数据，用于事务的回滚），执行事务命令锁资源但不提交，向协调者返回执
		行结果；
	第二阶段 do commit：
		基于第一阶段的投票结果决定整体回滚或者整体提交：
		所有参与者响应都是成功：协调者对所有参与者发送提交命令；
		有参与者响应失败或者超时：协调者对所有参与者发送回滚命令；
	问题：参与者和协调者之间可能会有网络异常，参与者可能会宕机，这两种情况都会导致：
		1.数据不一致：在第二阶段进行中协调者宕机或者网络异常，导致所有参与者无法提交，或者部分提交后协调者或者
		还没提交的参与者宕机，总结来说只有部分参与者收到commit，导致数据不一致；
		2.同步阻塞：所有参与该事务操作的参与者当前事务都处在阻塞状态，影响性能；最大的问题！！！
		3.协调者单点问题：导致参与者处于事务的资源锁定状态（可以通过选举一个新的协调者解决）；
		4.过于保守：没有容错，任何一个节点失败都会导致整体提交失败；
		5.协调者在二阶段宕机-恢复的时候，是否需要询问各个参与者事务提交情况，并继续事务的提交？

3pc：
	三阶段提交：
	1.在2pc的基础上在参与者上引入超时机制，降低阻塞范围，和2pc的主要区别在参与者；
	2.优化了2pc存在的问题：第一阶段太过激进，直接开始执行事务写入，如果过程中有某一个参与者无法执行，导致所有事务回
	滚，会白白浪费事务执行的时间和资源；
	3.参与者和协调者
	第一阶段 can commit：
		协调者发出包含事务内容的can commit询问，是否收到所有参与者的yes ACK（可以从尽早止损的方面思考）：
		是：对参与者来说类似于超时校验，进行第二阶段；
		否：协调者终止事务，参与者在超时没收到协调者响应或者宕机重启发现没有发出投票的话，自动终止事务；
	第二阶段 pre commit：
		如果一阶段所有参与者都响应yes ACK：对所有参与者执行事务预提交，同2pc的一阶段；
		协调者：二阶段出现参与者响应失败或者超时，协调者立即向所有参与者发出终止事务命令；
		参与者：二阶段超时没收到协调者的命令，自动终止事务；
	第三阶段 do commit：
		进入第三阶段，默认所有参与者都可以进行提交操作，每个参与者也认为其它参与者都可以进行提交操作（概率上）；
		二阶段发出预提交命令有有参与者响应失败：
		整体提交或者回滚，和2pc的第二阶段大体相同，不同的是参与者一段时间没有收到协调者发出的doCommit会自动提
		交事务；
	改进：
		1.第3阶段解决了网络原因导致参与者没有收到doCommit导致回滚产生的的数据不一致问题，以及本该向所有参与者
		发送doCommit的时候协调者宕机了导致的事务阻塞（建立在本来协调者要发送doCommit的前提下），减少了阻塞
		范围；
		2.协调者宕机后
		3.网络超时（参与者）：
			一阶段后的preCommit超时：参与者本身中断事务；
			二阶段后的doCommit超时：参与者自己提交事务，因为此前已经知道其他参与者在一阶段已经投了赞成票
			（否则也不会进入二阶段），所以乐观的认为其它的参与者事务可以提交（或者说已经提交），并且自身也
			在超时没有收到commit之后提交事务；
		网络超时（协调者）：两个阶段都是进行abort或者rollback
	问题：
		1.多一轮网络交互，意味着性能损耗，在某些情况下反而会降低性能；
		2.第3阶段解决了网络原因导致参与者没有收到doCommit导致回滚产生的的数据不一致问题，以及本该向所有参与者
		发送doCommit的时候协调者宕机了导致的事务阻塞；但是引发了：如果因为网络原因abort没有发出导致了本来应
		该回滚的参与者自动提交了，会导致数据不一致问题；
		3.三阶段的超时我理解是基于概率的，即乐观的认为过了一阶段以后所有参与者事务都能正常提交（大概率事件），但
		如果协调者发出的是rollback，那这里就有问题了，还是存在数据不一致；而数据强一致性的最终解决方案是paxos；
 

tcc：
	try-confirm-cancel，是2pc的一个变种
	try - 预先锁住资源
	confirm - 扣除资源 
	cancel - 回滚
	核心是补偿机制，非阻塞，因为是代码层实现两阶段提交，每个阶段的每个方法都可以独立提交，并且每个阶段都有对应的补
	偿（撤销）操作，缺点是业务侵入性强（个人感觉有点像mysql的write ahead log）；
	以电商场景为例，下单要先扣库存，但是不会直接扣，而是有一个库存占用字段，先通过这个字段占用库存，如果一阶段没成
	功，则回滚这个字段的占用值，如果一阶段成功了，就扣减实际库存；每个阶段都是独立提交，并且可重试补偿，因此：
		1.事务提交或者回滚就算因为网络等原因阻塞了也能保证最终的成功；
		2.因为每个阶段都是独立提交因此非阻塞；
	相当于通过另外引用类似于起日志作用的字段保证提交成功，但是由于有重试的存在，需要考虑接口的幂等性；实现tcc的关键
	在于软状态和重试/补偿；

paxos：
	场景
		多个提案者，多个接收者
	核心
		多数派原则
	流程
		提案
		选举
		学习
问题
