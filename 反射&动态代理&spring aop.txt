代理目的：不修改调用的代码和原本实现的代码，对逻辑做增强

api：Proxy.getProxyClass得到代理后的类对象，Proxy.newProxyInstance得到代理后的实例

需要实现InvocationHandler接口，通过invoke方法最终反射调用目标方法，并可以在调用前后做增强

做代理对原对象的方法做增强可以通过实现接口或者继承的方式
继承：重写父类方法，方法中super调用父类方法，前后可以增强
实现接口：与被代理对象实现同一组接口，代理类里面有一成员变量是被代理对象，代理类调用方法：增强逻辑加被代理对象的同名方法

java的动态代理，被代理类需要关联上Proxy对象和InvocationHandler（主要是实现增强逻辑，以及通过反射调用原方法）
java的动态代理选择继承Proxy类来实现代理功能，所以只能通过实现接口来做逻辑增强
其中InvocationHandler充当代理对象和被代理对象的桥梁
InvocationHandler.invoke入参：Proxy对象，method方法，方法入参

原理：
Proxy类在内存中生成一个代理对象（如果已经生成并且在缓存中存在就从缓存中取，否则重新生成），
具有和传入接口相同的方法，并且继承了Proxy类来实现代理功能，调用接口同名方法会调用父类的invoke方法，
并把对应的方法对象（已经在静态代码块初始化过）传入以供实现真正的被代理方法；
静态方法初始化了多个方法对象，其中有接口里面的方法，通过静态代码块初始化这些方法对象；
每次调用Proxy生成的代理对象的方法时，最终都会调用到InvocationHandler.invoke，并获取当前方法的method对象和入参传入
在invoke方法里做逻辑增强

补充：
q：为什么需要传入类加载器？
a：看源码主要是用来寻找是否类已经被加载到内存中了，就算是同一个class文件，被不同的类加载器加载就是不同的class对象，
   所以需要指定一个类加载器；提供代理类可以被不同的类加载器加载，理解上算是提供了一种打破双亲委派的模式；